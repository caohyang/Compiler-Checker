问题1-1：

`FuncDef`: 包括参数`ret_type`, `param_list`, `name`, `body`. `visit`函数先输出返回类型和函数名，然后调用`accept`函数继续访问节点的函数参数和函数体。

`BlockStmt`: 包括参数`body`（指向`block`的指针列表）。`visit`函数按缩进格式输出语句块，并继续访问每个语句。

`VarDef`: 包括参数`is_constant`, `btype`, `name`, `is_inited`, `array_length`, `initializers`. `visit`函数根据`is_constant`判断是否输出代表常量定义的字符串`const`，再输出类型，访问数组每一维的表达式，如果有初始化则输出初始值并访问对应表达式。

`InitVal`: 包括参数`isExp`, `elementList`, `expr`. visit函数根据`isExp`判断是否为表达式，若是则访问该表达式，否则按列表形式输出，并依次访问节点中的每个子节点。

`LVal`: 包括参数`name`, `array_index`. visit函数输出左值的名称，访问每一维的数组索引。

`FuncParam`: 包括参数`name`, `param_type`, `array_index`. visit函数输出函数参数的类型和名称，并遍历访问每一维的表达式（不访问空指针）。

`FuncFParamList`: 包括参数`params`. visit函数访问节点指向的所有参数。

总的来说，这些节点类都包含若干参数，`visitor`可以访问指针类型的对象。语法树的节点通过`accept`方法接受`visitor`对象，并在`accept`方法中回调`visit`方法。

问题1-2： 

在`build`目录下使用命令`./sysYFParser -emit-ast ../testcase.sy`，可得到语法树的输出结果为`int a = (2%3);`

Note: 上述结果与`testcase.sy`中的内容`int a = 2 % 3;`略有不同。

问题3-1：（实验总结）

1、遇到的困难与解决方案：

+ 最开始不知道如何上手，后来看到`SyntaxTreeChecker.h`中的内容后才明白要用这个文件中定义的方法完成语义检查。
+ 不知道样例归约后对应的`AST`节点——通过阅读`AST.md`和`SysYF语言定义.pdf`，结合`SyntaxTreeChecker.cpp`中给出的接口综合判断。
+ 出现段错误等问题时不易调试——使用gdb、print等方法，或猜测可能的原因并通读程序加以排查。
+ 无法解决未公开样例中的问题——通过完善其他方面的语义检查，并参考公开的样例。如`PW5-2`的样例18是我最后过的数据点，解决思路来源于公开的样例17：`int a, b=a+1;`是合法的，但我联想到，`int a=a+1;`是不合法的，因为右式中的a没有在这条语句之前定义。于是在程序中，需调整`Vardef`类的访问顺序。

2、实验难点与考察倾向：

+ c++函数的熟练使用
+ 如何在程序中包括所有可能出错的情况
+ 如何面向给定的接口编程
+ 对语义检查中访问者模式、作用域等概念是否理解透彻

3、整体实现思路与实现亮点：

+ 整体按照实验文档的顺序进行增量式编程，再对错误的样例逐个排除程序中的问题。
+ 在一个变量被定义时，程序会检查在第一层作用域是否已定义同名变量。这是由于函数只会在最外层（第零层作用域）定义，从而第一层包含了函数的参数信息。
+ 程序中多处对空指针做了特殊判断（并非所有处理都必要）。
+ 程序中保留了输出调试的注释，以及报错时反映错误类型的消息。

问题3-2：

1、`Expr`是基类，无法确定其衍生出的表达式子类类型。故语义检查器识别到`Expr`类时，不知道调用哪个表达式子类的方法判断表达式的类型。除非修改相应的文法和`AST`节点属性，建立属性的继承关系（文法复杂度会提高），否则语义检查器无法确定表达式的类型。

2、若将`SyntaxTreeChecker`类拆成多个子类，会导致代码的冗余和语义检查效率的降低。一个`AST`类可能会出现多种语义错误，而一种语义错误可能会出现在不同的`AST`类中。若每个子类处理一种语义错误，则除了处理语义错误的部分外，各个子类的程序是相同的（否则程序之间无法协调）。这样导致每次遍历`AST`时只能处理一种语义错误，若要检查所有类型的语义错误，则需多次遍历`AST`，时间开销增加。